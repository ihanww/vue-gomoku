# Design: 五子棋人机对战系统

## Context

### 当前状态

项目是一个使用 Vue 3 + TypeScript + Vite 的空白模板，已配置 Pinia 状态管理和 Vue Router。需要从零开始实现完整的五子棋人机对战游戏。

### 约束条件

- 使用现有技术栈，不引入新的外部依赖
- 需要支持移动端和桌面端响应式布局
- AI 计算需要在不阻塞 UI 的情况下执行
- Local Storage 容量限制（约 5MB）
- 需要保持代码可测试性

### 利益相关者

- 最终用户：游戏玩家
- 开发者：需要维护和扩展代码

## Goals / Non-Goals

### Goals

- 实现流畅的五子棋人机对战体验
- 提供可配置的 AI 难度
- 支持悔棋和复盘功能
- 提供良好的视觉反馈（动画、音效）
- 代码架构清晰，易于测试和维护

### Non-Goals

- 在线多人对战（未来可扩展）
- 复杂的禁手规则（采用简化规则）
- 机器学习 AI（使用规则基础的 Minimax）
- 服务器端数据存储（使用 Local Storage）

## Decisions

### 1. 架构模式：组合式 API + Pinia

**决策**：使用 Vue 3 Composition API 和 Pinia 进行状态管理

**理由**：
- Composition API 提供更好的类型推断和代码组织
- Pinia 是 Vue 官方推荐的状态管理方案，支持 TypeScript
- 相比 Vuex，Pinia API 更简洁，支持 Composition API 风格

**替代方案**：
- Vuex 4：API 较复杂，TypeScript 支持较弱
- 组件内部状态：不适合跨组件共享的游戏状态

### 2. AI 算法：纯 Minimax（无 Alpha-Beta 剪枝）

**决策**：使用基础 Minimax 算法，搜索深度限制在 2-6 层

**理由**：
- 用户选择"基础 Minimax"，算法实现简单
- JavaScript 单线程环境下，深度过高会导致界面卡顿
- 搜索深度 2/4/6 已能满足简单/中等/困难难度区分

**替代方案**：
- Minimax + Alpha-Beta 剪枝：性能更好，但用户未选择
- Web Worker 多线程：增加复杂度，暂不需要
- 启发式搜索：更复杂，后续可优化

### 3. 数据持久化：Local Storage

**决策**：使用浏览器 Local Storage 存储历史记录和统计数据

**理由**：
- 无需服务器，实现简单
- 数据量小（历史记录约 100 条 × 1KB）
- 用户数据本地隐私保护

**替代方案**：
- IndexedDB：API 复杂，对于小数据量过度设计
- Session Storage：数据不持久
- 服务器存储：需要后端支持

### 4. 组件设计：单一职责原则

**决策**：将棋盘拆分为 Board（容器）和 Cell（单个格子）组件

**理由**：
- Cell 组件可复用，只需关注单个格子的渲染
- Board 组件负责整体布局和交互逻辑
- 便于单元测试和性能优化

**替代方案**：
- 单一组件渲染整个棋盘：代码臃肿，难以维护

### 5. 音效实现：HTML5 Audio

**决策**：使用 HTML5 `<audio>` 元素或 Audio API

**理由**：
- 浏览器原生支持，无需额外库
- 可预加载音效文件确保即时播放

**替代方案**：
- Web Audio API：功能更强大但 API 复杂
- 第三方音频库：Howler.js 等，增加依赖

### 6. 动画实现：CSS Transitions + Transform

**决策**：使用 CSS transition 和 transform 实现动画

**理由**：
- 利用 GPU 加速，性能好
- 代码简洁，易于维护
- 支持通过 CSS 变量动态控制

**替代方案**：
- JavaScript 动画库（GSAP）：增加依赖和体积
- Web Animations API：浏览器支持不够完善

### 7. 类型定义：集中式类型文件

**决策**：在 `src/types/game.ts` 中集中定义所有游戏相关类型

**理由**：
- 类型定义集中管理，易于维护
- 避免循环依赖
- 便于类型复用

**替代方案**：
- 分散在各个文件中：难以查找和复用

### 8. AI 思考阻塞：异步状态标志

**决策**：使用 `isAiThinking` 状态标志防止用户在 AI 思考时操作

**理由**：
- 实现简单，只需禁用相关按钮
- 给用户清晰的反馈

**替代方案**：
- Web Worker：实现复杂，暂不需要
- 服务器计算：需要后端支持

### 9. 棋盘数据结构：二维数组

**决策**：使用 `BoardCell[][]` 二维数组表示棋盘

**理由**：
- 直观映射棋盘结构
- 访问效率 O(1)
- 易于胜负判定

**替代方案**：
- 一维数组：计算索引复杂
- Map 结构：性能较差

### 10. 路由结构：单页面应用

**决策**：使用 Vue Router 实现游戏页面和排行榜页面的导航

**理由**：
- 已配置 Vue Router
- 支持浏览器前进/后退
- 便于后续扩展更多页面

**替代方案**：
- 条件渲染单页面：不适合多页面场景

## Risks / Trade-offs

### 性能风险

**风险**：AI 在困难模式下（深度 6）计算时间长，可能阻塞 UI

**缓解措施**：
- 设置最大计算时间限制（如 3 秒）
- 超时后返回当前最优解
- 添加"AI 思考中..."加载动画
- 未来可考虑 Web Worker

### 内存风险

**风险**：历史记录过多可能超过 Local Storage 容量

**缓解措施**：
- 限制历史记录上限（100 条）
- 自动删除最旧记录
- 实现数据压缩或清理功能

### 兼容性风险

**风险**：某些浏览器可能不支持 Web Audio API

**缓解措施**：
- 音效系统优雅降级，静默失败
- 检测 API 可用性并提供降级方案

### 测试覆盖风险

**风险**：游戏逻辑复杂，测试覆盖可能不足

**缓解措施**：
- 优先测试核心逻辑（胜负判定、AI）
- 使用 E2E 测试覆盖完整流程
- 保持代码模块化便于测试

### 用户体验风险

**风险**：移动端棋盘可能过小，操作不便

**缓解措施**：
- 响应式设计，自动缩放棋盘
- 支持手势缩放（未来）
- 优化触摸区域大小

## Migration Plan

### 阶段一：核心功能（MVP）

1. 创建类型定义
2. 实现游戏引擎（状态管理、胜负判定）
3. 实现棋盘组件和交互
4. 实现基础 AI（简单难度）

### 阶段二：增强功能

1. 添加中等和困难难度
2. 实现悔棋功能
3. 实现历史记录存储
4. 添加游戏控制面板

### 阶段三：完善体验

1. 添加动画效果
2. 添加音效系统
3. 实现复盘功能
4. 实现排行榜

### 阶段四：测试和优化

1. 编写单元测试
2. 编写 E2E 测试
3. 性能优化
4. 响应式适配

### 回滚策略

- 每个阶段完成后提交代码
- 使用 Git 分支管理不同功能
- 发现问题可快速回退到上一稳定版本

## Open Questions

1. **AI 首步策略**：是否需要预设开局库以提高开局质量？
   - 后续优化时考虑

2. **音效资源**：使用外部音效文件还是内嵌 Base64？
   - 建议使用外部文件，便于管理和更新

3. **复盘功能**：是否需要支持复盘时的棋谱导出？
   - 可作为未来功能

4. **排行榜**：是否需要支持跨设备同步？
   - 需要后端支持，暂不考虑

5. **动画性能**：低端设备是否需要自动禁用复杂动画？
   - 实现 `prefers-reduced-motion` 媒体查询支持
